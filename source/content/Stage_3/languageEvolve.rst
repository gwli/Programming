现在对编程玩也快十年了，每学一门语言都是一种逻辑思维的表达。但是逻辑是不会断演化的。
但是代码还没有。虽然有一些进度，从静态语言到动态语言，到模板，再泛型元编程。以及后面的图灵机。以及元胞机，自己在追求那就是代码自动演化。如何让代码自我发展。你每执行一次，就相当于成长了一岁。只要不断执行。它就能不行断的演化。就像分形与混沌一样。不断寻找自己不动点，然后从不动点进一步演化。

以前追求代码短小，现在追求图灵完备，自我演化。
自动生成代码 可以实现自我演化推导
根据需求自动生成代码。  例如，我要做小波变换， 它就自动生成小波变换代码。 
同时地图建立也是样的，可以自动生成代码框架。 如何知识走成一个闭环系统也就实现了这个。


演化的核心
==========

#. 从一堆点找到并判定不动点。
#. 从现有不动点，根据规则生成新一系列点。再回到第一步。

如果判定，就要根据不同的理论了。各种图形的方程了。 如何判断定它们就是图形。
找到图形，找到不动点。 生成新点。
每执行一次就要找出新的不动点，并且代码能够自我保存状态，改写自身。一直往下发展。

演化的最简单就是替换，

.. code-block::
   for (;):
      next = f(current)
      current = next

数据驱动开发
============

根据数据的特性，生成代码，进行验证，进一步迭代。
http://blog.csdn.net/jxt1234and2010/article/details/45201421
这样开发就是测试，测试就是开发。也就是不断优化。不断发现的过程。
有了测试用例自动转化成程序的机制，开发人员的主要工作就是搭建自动编程环境。基于对需求的理解统写测试用例，并且对自动生成的代码进行测试。这个工作事实上就是现在测试人员的工作，原来软件开发流程中测试环节已经没有存在价值。
由于程序自动化生成，避免人写代码的低级错误的可能，产品质量更有保障。

数据就是程序。

一个程序好不好，一方面在于其需求设计是否合理，测试用例是否设计完备，另一方面，在于构建程序的环境是否有足够丰富的代码源(早期来源于程序员的编写，后期主要是自动生成的有效代码段),是否有足够的计算能力。

总而言之，程序来源于数据，好坏取决于数据量和数据处理能力。

数据存储与输出
==============

#. 现在各种各样的输出格式，都需要进行二次的处理才能适配。 为什么直接生成数据与代码直接使用。 对于编程语言最基本数据结构就是list与dict. 生成这些，再加上一些元分析。自动得出结论。没有必要人工添加各种代码。再进等待。
   所以系统的应该是标准结构化并且适用于适用于代码匹配。实现一种自动匹配接口。
   只要你的处理符合这些接口。我们就能自动做这些分析。而不是每一次都要重新分析。
#. 输出成第三方输入，
   - log的输出，设计规范一些，直接生成python，而不需要分析代码。
     例如log格式规整一些，就生成python的dict就行。
   - 生成代码形成，例如一面
     
     .. code-block:: python

        echo "python = [" find |xargs -I % echo "%", echo "]"
        就直接生成python代码了。 直接用高阶函数就可以实现大部分东东了。
        研究一下，logging format.
   
#. 好的代码，是为了写更少的代码，而不是写一坨垃圾，再利用另一坨来清理它。而没有很好的复用。没有复用就没有复利。同样执行的次数就是复利产生的价值。如果复用十次，那效果惊人了。每天要有一个delta,并且这个delta要在以后能够不断的复用。复用率越高越好。每天前进一小步，但是要保证能够复用。

#. 每天都要一些能让后面复用的东东。


程序优化方式
============

#. 突变，例如神经网络调参数
#. 通过外部数据优化（机器学习），改变模参数
#. 人为编写代码
现在发展为三个阶段，

#. 人写代码的时代
#. 人写框架，用机器学习优化的时代
#. 代码框架演化的的时间

现在初步进入了第二个阶段。 实现全面的JIT估计就是第三阶段的到来。

机器证明
========

`形式证明:机器的光荣与人的梦想 http://songshuhui.net/archives/8745>`_  特别是在证明的时候，那么多路，如何灵光一现，如果让机器来模枋人类的灵光一现。
程序验证要求通过推理或者穷举的手段来判定程序的行为是否符合规约，而程序设计语言的复杂性又使得程序的复杂性随着程序的规模呈指数级增长，因此程序验证目前只用于证明一些关键的核心模块的正确性而没有得到更广泛的应用。

动态测试通过考察尽可能多的测试用例来保证程序的质量，程序验证则希望通过逻辑推理和计算判定程序是否正确。

静态分析是介于动态测试和程序验证之间的一种方法。各种静态分析技术试图在精确性可招展性之间做出平衡。  采用类型推导和抽象解释的方法，分析结果不够精确，采用定理证明的方法，由于算法复杂性的限制，很难处理实际应用中大规模程序，将符号执行和约束求解结合在一起，路径的选择会存在性能问题。


编译器与逆向软件工程的区别
==========================

编译器实现中需要的程序分析以优化为目的，着重于具体数据的别名，依赖关系等底层信息的分析。

逆向软件工程则以分析软件的体系结构为目的，在函数的抽象层次上进行分析。 

做一个最小系统
===============

#. 能够自身坐版本控制，最好自己执行一次，提交一个版本。
#. 同时能够自我二分回退查找
#. 代码能够改写自身。 可以通过copy自己，同时实现来改写自己。自身的数据结构也要合适才行。其实也就是相当于深度学习过程可视化的过程。

做的过程就有像 bash的的管道一样，每执行一次能够把管道加长一次。
通过聚类算法，再加一些判别最后看看能够图像得出什么。


至于lambda calculus，或任何继承的Haskell、Prolog之类的语言，它们永远都不会有闭包，因为只有有值和状态的语言才需要闭包的概念，而这些完全纯的语言自然是没有闭包概念的。

利用shell与racket以及clips来实现自己查询系统 
=============================================

把自己语言变成一个函数名， 让shell能接受自然语言。 然后自己把每一句总结出来的话，变成用下划线连接起来，就是一个函数名。就可以不断的执行下去了。例如可以按照优级来排序。
如何面试，变成一个shell命令。 它叫自动给出几个选项。
只需要把shell 修改一下，这样加一个前缀就搞定了，例如 my how to interview ,然后直接发搜索出 how_to_interview的过程
另外可以提供一个context,让自己可以不断的交互下去。 把原来自然语言那一部分直接换成函数。调用过程。
对就是把交互的过程，变成一个callchain。 只要把自然语言变成函数名就够了。
这样把交互过程以及交互过程。一个callchain的实现。就是一种思维过程的体现。

这些只是搜索直接的相关性，而正确的做法，是放在网上，让搜索快速找到自己的东东。

元胞机
======


元胞机在解决计然过程与计算系统以及传统的数学之间关系。wolfram已经开始这种这个大门。
https://www.whitman.edu/Documents/Academics/Mathematics/andrewgw.pdf 并且之间到底是什么关系。the nature of code 正是研究这一过程。 


基本上元胞机都是图灵完备的。 只要集合，再加上闭包计算。

初等元胞机基本要素
#. 空间
#. 状态集
#. 邻居，根据不同定义有冯-诺依曼型，Moor型，扩展的摩尔型。 马哥勒斯型，
#. 演化规则， 一个元胞的生死由其邻居决定。 也就是一定要有非线性。相于动力函数。 http://www.cs.sun.ac.za/rw711/resources/CAtut3.pdf 在这些演化规则中是不是具有规律，例如具有基函数等。
元胞自动机的核心概念有：元胞、状态、元胞空间、邻居、转换规则、演化等
 
要有一个元胞机框架，主要是演化规则定义。
例如python PyCA的lib 可以拿来演示的。

用wolfram观点，元胞机可以解释宇宙万物。 一种研究生学习状态的研究。
考上研究生，每个人就有了一个元胞及其状态（在读研究生）；同一个学术团队（广义来讲，同一个导师的学生、同一个专业的学生和导师以及这些老师、学生延伸的领域同行等）就是一个元胞空间；邻居规则可以是冯-诺依曼(Von. Neumann)型、摩尔(Moore)型、扩展的摩尔(Moore)型、马哥勒斯 (Margolus)型等还是其他，可类比为同门邻居、同专业邻居、同系邻居、同学院邻居、同校邻居等；转换规则可就千差万别了，面对不同的状态、元胞空间及邻居，可以有多种转换规则；然后就是从研一开始演化，直到毕业甚至一生。
http://blog.sciencenet.cn/home.php?mod=space&uid=43347&do=blog&id=277417


可以用processing现成natureofcode中例子直接来学或者wolfram来试验。

http://www2.econ.iastate.edu/tesfatsi/cellularautomataintro.lt.pdf 一些模型参数。

元胞机的发展过程
================
这里详细的入门教程 http://users.utu.fi/jkari/ca/CAintro.pdf

#. Wolffram 的初等元胞机。
对于初等元胞机可以在wolfram中直接实验的，https://reference.wolfram.com/language/tutorial/CellularAutomata.html. 只指定规则，初使状态。就可以查看其过程，或者最终结果还是全面结果。
对于其图灵完备性的证明，以及其他性质证明http://www.complex-systems.com/pdf/15-1-1.pdf， 图灵完备，包含周期性。 也就是有界。
http://tutorials.siam.org/dsweb/catutorial/ 这里对于初等也有现成的研究与例子。就一个初等元胞机就能生成复杂的系统。

#. 生命游戏。主要问题邻域的半径+总体的数量。

https://llk.media.mit.edu/projects/emergence/  
http://stevenklise.github.io/ConwaysGameOfLife
https://bitstorm.org/gameoflife/  
http://www.math.com/students/wonders/life/life.html
http://www.ibiblio.org/lifepatterns/
http://cell-auto.com/

http://wwwhomes.uni-bielefeld.de/achim/freq_top_life.html 最常见的生命模型。
   生命游戏模型已在多方面得到应用。他的演化规则近似地描述了生物群体的生存繁殖规律:在生命密度过小(相邻元胞数之2)时，由于孤单、缺乏配种繁殖机会、缺乏互助也会出现生命危机，元胞状态值由1变为0;在生命密度过大 (相邻元胞数>3)时，由于环境恶化、资源短缺以及相互竞争而出现生存危机，元胞状态值由1变为0;只有处于个体适中(相邻元胞数为2或3)位置的生物才能生存(保持元胞的状态值为1)和繁衍后代(元胞状态值由0变为1)。正由于它能够模拟生命活动中的生存、灭绝、竞争等等复杂现象，因而得名"生命游戏"。J·H·Conway还证明，这个元胞自动机具有通用图灵机的计算能力(谢惠民，1994;李才伟，1997)，与图灵机等价，也就是说给定适当的初始条件，生命游戏模型能够模拟任何一种计算机。
这里

例如在游戏中生成洞穴https://gamedevelopment.tutsplus.com/tutorials/generate-random-cave-levels-using-cellular-automata--gamedev-9664。

已经有人探索好生命pattern. http://www.conwaylife.com/wiki/Main_Page，​http://golly.sourceforge.net/ 有开源工具供你探索。
`如何优雅地用元胞自动机炼蛊？ <https://www.zhihu.com/question/37530794>`_ 初始状态与密度与最终的生命模型。

搞理论的科学家，只把这个规则和定义作为一个用于各种性质方面研究、证明、或者展示的例子，实际去乐于花很多时间，研究如何创造什么结构（很多时候也是要运气）、搞些漂亮的宏伟的高端的来达到各种目的的人，比玩过这个的科学家，估计更是少数……



#. 格子自动机(Lattice-GasAutomata).在流体力学与统计物理学中具体化。主要是模拟navier-stroker方程，以及波尔兹曼方程。

#. Langton 和能自我复制的元胞自动机



分类
====
#. 平稳型  不动点，变化终结于恒定的图像
#. 周期型, 图像出现性变化
#. 混沌型，就像随机态
#. 复杂型。最具有研究价值是第四种，因为这类元胞自动机被认为具有"突现计算"(Emergent Computation)功能，研究表明，可以用作广义计算机(Universal Computer)以仿真任意复杂的计算过程。另外，此类元胞自动机在发展过程中还表现出很强的不可逆(lrreversibility)特征，而且，这种元胞自动机在若干有限循环后，有可能会 "死"掉，即所有元胞的状态变为零

还有按照维度的分类方法。

应用类型
--------

在实际应用过程中，有的元胞自动机模型对其中的某些特征进行了扩展，有的在规则设计中引入随机因素，如：森林火灾模型。 又如，在交通、通讯发达的今天， 研究流行病或计算机病毒的传播问题时， 我们还可以将空间背景换成复杂网络的结点，用网络邻接点作为邻居。这样的调整显然比仍旧使用二维欧氏空间、采用欧氏距离的模型更加符合实际情况。 在大型场所人群紧急疏散问题模拟研究中，可以考虑年龄、性别等因素，即元胞不是同质的，更加有利于使模拟系统接近真实系统。

元胞自动机将简单与复杂、 微观与宏观、 局部与整体、 有限与无穷、 离散与连续等
一对对哲学范畴紧密联系在一起，可望成为探索复杂科学的利器。

分层模块化编程
================

现在已经是一个趋势了，multi-stage programming。 一种是生成别人，就像现在元编程，另一种那就是优化自己，那就代码的自我演化了。
对于前者对于加速计算中已经很多了，例如thearno,以及Terra In Lua. 
其实也CUDA也是C的扩展，相当于同样的语法，添加一些扩展，但是用不同的编译与执行环境。
Terra: a multi-stage language for high-performance computing
http://xueshu.baidu.com/s?wd=paperuri:(f07cfc1eb4f6e17bd78c4598b285e298)&filter=sc_long_sign&sc_ks_para=q%3DTerra%3A+a+multi-stage+language+for+high-performance+computing&tn=SE_baiduxueshu_c1gjeupa&ie=utf-8&sc_us=18024398585137206599


Spiral in Scala: Towards the Systematic Construction of Generators for Performance Libraries
What tools and features provided by programming languages and environments can facilitate the development of generators for performance libraries?

并且LMS(Lightweight MOdular Staging). 实现一种中间形式，然后进行各种优化，主要是 rule rewrite,以及transformation. 对于多种数据结构的形式， Array of Structure 还是 Structure of Array.

Abstraction ver  Data Representations. 

#. Precomputation. 
#. selection. 
#. 描述算法与问题
#. 指定特定优化，例如某种硬件实现的选择，或者 rule rewrite.
#. 设计高层数据结构，方便指层的重构。

算法描述语言
============

Liszt 用mesh 结构来解差分方程，然后自动实现MPI，CUDA等代码。http://graphics.stanford.edu/hackliszt/
The_Pochoir_Project 用来生成stencil 代码的编译器 http://groups.csail.mit.edu/sct/wiki/index.php?title=The_Pochoir_Project

例如对于计算流体仿真是用波振面 分块并行的计算方法。


nature of code
==============
http://github.com/shiffman/The-Nature-of-Code-Examples

建立随机，然后利用非平均随机来改变运动的方向。

如何让物体沿着曲线的方向移动，那就是沿线曲线的切线方向移动一个单位。 例如滚屏，也就是一个求余就搞定了。


遗传算法
========

也是代码演化的一种方式，也当做是一种搜索方式。首先得有一个群，然后crossover,并且选出优势，再进一步生成，同时有一部分的变异。
https://www.zhihu.com/question/23293449. 并且相信，最好的结果是可以由当前的结果进化得到的。

