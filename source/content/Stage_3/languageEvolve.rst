现在对编程玩也快十年了，每学一门语言都是一种逻辑思维的表达。但是逻辑是不会断演化的。
但是代码还没有。虽然有一些进度，从静态语言到动态语言，到模板，再泛型元编程。以及后面的图灵机。以及元胞机，自己在追求那就是代码自动演化。如何让代码自我发展。你每执行一次，就相当于成长了一岁。只要不断执行。它就能不行断的演化。就像分形与混沌一样。不断寻找自己不动点，然后从不动点进一步演化。

以前追求代码短小，现在追求图灵完备，自我演化。
自动生成代码 可以实现自我演化推导
根据需求自动生成代码。  例如，我要做小波变换， 它就自动生成小波变换代码。 
同时地图建立也是样的，可以自动生成代码框架。 如何知识走成一个闭环系统也就实现了这个。


演化的核心
==========

#. 从一堆点找到并判定不动点。
#. 从现有不动点，根据规则生成新一系列点。再回到第一步。

如果判定，就要根据不同的理论了。各种图形的方程了。 如何判断定它们就是图形。
找到图形，找到不动点。 生成新点。
每执行一次就要找出新的不动点，并且代码能够自我保存状态，改写自身。一直往下发展。

数据驱动开发
============

根据数据的特性，生成代码，进行验证，进一步迭代。
http://blog.csdn.net/jxt1234and2010/article/details/45201421
这样开发就是测试，测试就是开发。也就是不断优化。不断发现的过程。
有了测试用例自动转化成程序的机制，开发人员的主要工作就是搭建自动编程环境。基于对需求的理解统写测试用例，并且对自动生成的代码进行测试。这个工作事实上就是现在测试人员的工作，原来软件开发流程中测试环节已经没有存在价值。
由于程序自动化生成，避免人写代码的低级错误的可能，产品质量更有保障。

数据就是程序。

一个程序好不好，一方面在于其需求设计是否合理，测试用例是否设计完备，另一方面，在于构建程序的环境是否有足够丰富的代码源(早期来源于程序员的编写，后期主要是自动生成的有效代码段),是否有足够的计算能力。

总而言之，程序来源于数据，好坏取决于数据量和数据处理能力。

数据存储与输出
==============

#. 现在各种各样的输出格式，都需要进行二次的处理才能适配。 为什么直接生成数据与代码直接使用。 对于编程语言最基本数据结构就是list与dict. 生成这些，再加上一些元分析。自动得出结论。没有必要人工添加各种代码。再进等待。
   所以系统的应该是标准结构化并且适用于适用于代码匹配。实现一种自动匹配接口。
   只要你的处理符合这些接口。我们就能自动做这些分析。而不是每一次都要重新分析。
#. 输出成第三方输入，
   - log的输出，设计规范一些，直接生成python，而不需要分析代码。
     例如log格式规整一些，就生成python的dict就行。
   - 生成代码形成，例如一面
     
     .. code-block:: python

        echo "python = [" find |xargs -I % echo "%", echo "]"
        就直接生成python代码了。 直接用高阶函数就可以实现大部分东东了。
        研究一下，logging format.
   
#. 好的代码，是为了写更少的代码，而不是写一坨垃圾，再利用另一坨来清理它。而没有很好的复用。没有复用就没有复利。同样执行的次数就是复利产生的价值。如果复用十次，那效果惊人了。每天要有一个delta,并且这个delta要在以后能够不断的复用。复用率越高越好。每天前进一小步，但是要保证能够复用。

#. 每天都要一些能让后面复用的东东。


程序优化方式
============

#. 突变，例如神经网络调参数
#. 通过外部数据优化（机器学习），改变模参数
#. 人为编写代码
现在发展为三个阶段，

#. 人写代码的时代
#. 人写框架，用机器学习优化的时代
#. 代码框架演化的的时间

现在初步进入了第二个阶段。 实现全面的JIT估计就是第三阶段的到来。

机器证明
========

`形式证明:机器的光荣与人的梦想 http://songshuhui.net/archives/8745>`_  特别是在证明的时候，那么多路，如何灵光一现，如果让机器来模枋人类的灵光一现。
程序验证要求通过推理或者穷举的手段来判定程序的行为是否符合规约，而程序设计语言的复杂性又使得程序的复杂性随着程序的规模呈指数级增长，因此程序验证目前只用于证明一些关键的核心模块的正确性而没有得到更广泛的应用。

动态测试通过考察尽可能多的测试用例来保证程序的质量，程序验证则希望通过逻辑推理和计算判定程序是否正确。

静态分析是介于动态测试和程序验证之间的一种方法。各种静态分析技术试图在精确性可招展性之间做出平衡。  采用类型推导和抽象解释的方法，分析结果不够精确，采用定理证明的方法，由于算法复杂性的限制，很难处理实际应用中大规模程序，将符号执行和约束求解结合在一起，路径的选择会存在性能问题。


编译器与逆向软件工程的区别
==========================

编译器实现中需要的程序分析以优化为目的，着重于具体数据的别名，依赖关系等底层信息的分析。

逆向软件工程则以分析软件的体系结构为目的，在函数的抽象层次上进行分析。 

做一个最小系统
===============

#. 能够自身坐版本控制，最好自己执行一次，提交一个版本。
#. 同时能够自我二分回退查找
#. 代码能够改写自身。 可以通过copy自己，同时实现来改写自己。自身的数据结构也要合适才行。其实也就是相当于深度学习过程可视化的过程。

做的过程就有像 bash的的管道一样，每执行一次能够把管道加长一次。
通过聚类算法，再加一些判别最后看看能够图像得出什么。


至于lambda calculus，或任何继承的Haskell、Prolog之类的语言，它们永远都不会有闭包，因为只有有值和状态的语言才需要闭包的概念，而这些完全纯的语言自然是没有闭包概念的。

利用shell与racket以及clips来实现自己查询系统 
=============================================

把自己语言变成一个函数名， 让shell能接受自然语言。 然后自己把每一句总结出来的话，变成用下划线连接起来，就是一个函数名。就可以不断的执行下去了。例如可以按照优级来排序。
如何面试，变成一个shell命令。 它叫自动给出几个选项。
只需要把shell 修改一下，这样加一个前缀就搞定了，例如 my how to interview ,然后直接发搜索出 how_to_interview的过程
另外可以提供一个context,让自己可以不断的交互下去。 把原来自然语言那一部分直接换成函数。调用过程。
对就是把交互的过程，变成一个callchain。 只要把自然语言变成函数名就够了。
这样把交互过程以及交互过程。一个callchain的实现。就是一种思维过程的体现。

这些只是搜索直接的相关性，而正确的做法，是放在网上，让搜索快速找到自己的东东。

元胞机
======

基本上元胞机都是图灵完备的。 只要集合，再加上闭包计算。

初等元胞机基本要素
#. 空间
#. 状态集
#. 邻居
#. 演化规则， 一个元胞的生死由其邻居决定。 也就是一定要有非线性。
元胞自动机的核心概念有：元胞、状态、元胞空间、邻居、转换规则、演化等
 
要有一个元胞机框架，主要是演化规则定义。
例如python PyCA的lib 可以拿来演示的。

用wolfram观点，元胞机可以解释宇宙万物。 一种研究生学习状态的研究。
考上研究生，每个人就有了一个元胞及其状态（在读研究生）；同一个学术团队（广义来讲，同一个导师的学生、同一个专业的学生和导师以及这些老师、学生延伸的领域同行等）就是一个元胞空间；邻居规则可以是冯-诺依曼(Von. Neumann)型、摩尔(Moore)型、扩展的摩尔(Moore)型、马哥勒斯 (Margolus)型等还是其他，可类比为同门邻居、同专业邻居、同系邻居、同学院邻居、同校邻居等；转换规则可就千差万别了，面对不同的状态、元胞空间及邻居，可以有多种转换规则；然后就是从研一开始演化，直到毕业甚至一生。
http://blog.sciencenet.cn/home.php?mod=space&uid=43347&do=blog&id=277417


可以用processing现成natureofcode中例子直接来学或者wolfram来试验。

应用类型
--------

在实际应用过程中，有的元胞自动机模型对其中的某些特征进行了扩展，有的在规则设计中引入随机因素，如：森林火灾模型。 又如，在交通、通讯发达的今天， 研究流行病或计算机病毒的传播问题时， 我们还可以将空间背景换成复杂网络的结点，用网络邻接点作为邻居。这样的调整显然比仍旧使用二维欧氏空间、采用欧氏距离的模型更加符合实际情况。 在大型场所人群紧急疏散问题模拟研究中，可以考虑年龄、性别等因素，即元胞不是同质的，更加有利于使模拟系统接近真实系统。

元胞自动机将简单与复杂、 微观与宏观、 局部与整体、 有限与无穷、 离散与连续等
一对对哲学范畴紧密联系在一起，可望成为探索复杂科学的利器。

分层化模块化编程
================

现在已经是一个趋势了，multi-stage programming。 一种是生成别人，就像现在元编程，另一种那就是优化自己，那就代码的自我演化了。
对于前者对于加速计算中已经很多了，例如thearno,以及Terra In Lua. 
其实也CUDA也是C的扩展，相当于同样的语法，添加一些扩展，但是用不同的编译与执行环境。
Terra: a multi-stage language for high-performance computing
http://xueshu.baidu.com/s?wd=paperuri:(f07cfc1eb4f6e17bd78c4598b285e298)&filter=sc_long_sign&sc_ks_para=q%3DTerra%3A+a+multi-stage+language+for+high-performance+computing&tn=SE_baiduxueshu_c1gjeupa&ie=utf-8&sc_us=18024398585137206599
