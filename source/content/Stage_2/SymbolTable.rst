Introduction 
=============

符号表在编译的重中之中。符号表构造的好与坏，直接有关系着优化与调试。
#. `GCC 符号表 调试信息 <http://wenku.baidu.com/view/333dc0553c1ec5da50e2703e.html>`_ 
#. `symbol table course <http://wenku.baidu.com/view/0ce247d7b9f3f90f76c61be0>`_   目前的组成，符号地址，类型与范围，符号，以及源码中行号，以及引用的行号。这些都是记录在符号表中。

当然符号表也是可以删除的，在计算机本身的执行中是不需要的。如何将指令与源码关联起来，就是通过符号表。符号表会记录符号的名字，以及其对应的内存地址。 一个符号的名字，不同的版本与平台，记录的方式也是不一样的，有的记录相对地址，有的记录绝对地值，例如文件目录名加上行号以及符号名本身，有的就只有符号名本身，另一个那就是类的内的符号是不是也要代有路径。如果保证，版本一致，函数的地址，然后自己手工去查符号表来得到这个是哪一个函数。  所以当发现即使有符号表还是找不符号，是真的没有。还是因为符号的命名规则与查询的规则不一样。   当然可以直接使用` gdb  <Work.HowToDebug>`_ 中info 查看地址以及符号表。当然也会类似于nm 这样的的命令行来操作。

所在就pentak的调试中，pentak会自动把系统库的符号表pull回来，并加载。而应用程序自然库需要自己加添加到 gdb.setup来手工指定。 gdb指动本身。当然也动态的加载指令。但是是自动更新符号，还是需要手动更新呢。 这个可以试一试QuadD的手工加载功能。  同时也要看pentak是不是也可以手动加载。因为pentak也是用的gdb.我看看是不是可以直接gdb进程发命令。也就是调用进程中函数。有了办法了，直接使用插入线程的方法，来执行我的东西`直接使用插入线程的方法 <http://stackoverflow.com/questions/15767482/using-c-sharp-to-call-a-function-from-another-process>`_  或者就像gdb 中attach中功能，直接attach到另一个进程上。来控制另一个进程。

远程debug时，远程回来的信息很有限，主要就是地址，然后所有解析都是在本地执行的。
而函数的调用关系，是需要在编译的时候，加入调用栈指针的记录的。 而且记录不记录这个值，可以能硬件直接实现也可以通过多执行一条指令来自己实现。如果硬件实现，例如ARM就会有LT这样的专用寄存器。


但是如果你采用优化技术可能就会造成符号表信息的不准确。

`线程注入 <ThreadInjection>`_ 
See also
========


Thinking
========

