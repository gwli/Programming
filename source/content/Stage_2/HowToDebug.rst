**********
HowToDebug
**********

Introduction
------------

调试程序很多方法,解决问题的最重要的方法，那就是不断narrow down,直到减少范围，直到找到root cause, 用log,debug能快速得到callstack等等线索。 因为模式设计就那几种，自己停下来想想，按照概率最大蒙也蒙的出来。
如果不能，选模块的分割，再了解流程再进一步narrow down. 就像修改那个 CMake 生成 Deploy 选项一样。 最终就只需要 else 语句就搞定了。

一个难点，那就是搭建调试环境，只要方便。最好方法那就是能在出错地方停下来(例如像pdb.set_trace()这样的功能最方便)，即使不能可以打log.



如果能到源代码
==============

#. 添加编译选项使其具画出call_graphic. 或者直接使用 VS中智能分析出来的。
#. 能否换成clang编译来优化一下代码。
#. framework pipepline 查起。然后不断的narrow down.
#. 通过读源码就得到答案，遇到问题，就要能够去想哪里出了问题。然后来猜想加验证。

strace and sreplay
------------------

*strace* 与 *sreplay* 可以抓取系统调用并且能够回放。例子见[streplay]_

.. [sreplay] http://people.seas.harvard.edu/~apw/sreplay/

如何让自己的程序变的动态可调试
------------------------------

#. 在自己的代码中全用 *命令行参数处理* 以及 *logging等级处理* 例如syslog,以及NLOG等的使用。
#. *C* 语言中可以采用 :c:func:`assert` 函数来定制调试，并且这些是通过宏控制的。打印出错信息。然后限出。
#. 每一个系统都会支持各种event,在处理前后都加上hook来capture.
#. 另一种方式那就是把内存当成一个存储系统并在上面加载一个文件系统。这样就可以高效的存储了。充分利用各种cache. 例如debugfs,tempfs,/proc/ 都是直接存储做到内存上。可以非常方便查询各种信息。
#. 充分利用配制信息，windows与linux是越来越像,都开始在home目录下写各种配制了。



如何调试并行调试
----------------

这个可以参考CUDA的并行调试。一个重要问题那就是对线程的控制，CUDA提供了基于lanes,warp,block,grid的,以及任意的frezen/thaw,以及支持与与或非的查询条件。可以方便过滤那些thread的查看。



调试都需要信息
--------------

debug Symbols 信息，有了符号表才能符号表地址对应起来，并且还源码对应起来了。对于GDB来说，那就需要设置 symbols directory, 另外那就是源码目录。还有那就是如何起动。
for apk, they need androidManifest.xml to get the package name to start it.


signal
======

也就是kernel发现在东东，来通知应用程序来处理， 例如键盘有了输入，硬件中断在软件就叫signal. 也不是操作系统告诉你发生了什么事情，至于你怎么处理那是你的事情，除了一些标准的消息kernel会强制处理之外，例如kill -9 等等。 exception，就是kernel发现你做错了来通知你。你丫搞杂了。


条件断点使用
============

道理早就懂，但是用的时候就想不起来，一个原则，那就是尽可能停下来地方尽可能接近出错的地方，包括时间与空间。再简单的场景: 你实现了一本功能，有很地方会用到它，突然其中一个调用crash了，或者出了问题。直接下断点，就会在没有crash的地方停下，停下来n多次。这个时间就需要加一些条件来帮助你停下来。

#. 如果有明确的信息可以知道在什么条件下会出现，例如其caller,或者某个具体值，直接上条件断点。直接停到最佳地方，而不是手工去点next.
#. 如果事先没有明确信息，可以先用trace的功能，打印出前后上下的context信息。 然后再根据这些信息设置条件断点。

所以快速的解决应该最多三步就能搞定。

#. 搭建环境
#. 明确断点信息
#. 停到最佳位置
#. 在第二步与三步之间采用二分法，无限细分下去，直到找到原因。 因为经常出错的事，我们分开验证A,B两部，都是正确的，但是合在一起就会出错。但是这两者已经离的很近了，并且或者从经验上认为是一致了。感觉已经没有办法了。实在是想不出来是哪里出错。
而实际上就是这个细微的差别出现的问题。 就像我自己项目中 从逻辑上，大的功能块上
二分，到代码行二分，再进一步到汇编指令二分。大部分时候，大家只能走到逻辑上二分，就以为到头了。

.. code-block:: perl

   system("fadfa")
   exit(0)

实际代码中在system("fadfa")就已经crash了，但已经还是想当然以为exit(0)执行了。




如何搭建环境
------------

其实也就是现场截面的恢复。其实就是现场中断与恢复。以前也只是说一说，现在看来用到实际中了。

大的应用程序，那就是保存其环境变量以及输入与输出。 就可以直接切入环境，而不需要从头运行需要大量的时间。

对一个函数来说，也就是输入输出，以及相关的全局变量而己。而这些都是可以通过trace来得到。
