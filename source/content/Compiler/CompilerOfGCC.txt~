:author: GangweiLi
:comment: No
:CreateDate: 2014-08-17
:status: C
:name: CompilerOfGCC

stage of GCC
------------

对于程序的各个过程现在才有更深的认识，以前停留在浅层的认识。尤其是在IDE上更是不知道怎么回事。真实的过程。就拿C语言来说。
首先要区分的那就是编译与链接。编译的时候，是以文件为单件的，相互独立的。最终链接成一个应用程序。但是这个应用程序也非得完全意义的应用程序。根据不同的操作系统，会有不同要求。例如每一个库会公用的，哪些需要独立提供的。例如操作系统是如何操作一个应用程序的。

编译错误，那就是语法错误，例如有些地方语法错了。例如类型转换出错，还有未定义等。重复定义（这个也可能链接错误）等。链接错误，最常见那就是一些符号找不着，或者什么类型不能识别，也是相关的库没有加载。另外一个不同的库之间相互冲突了，例如两个库有相同的名字符号，并且作用与方法却不一样。也就是命名空间冲突了。 所以出现了错误，首先要解决是这是一个编译错误，还是链接错误。
找不到的，就要知道它的库的搜索路径是什么，这些路径是不是没有相关的库。通用的规则那就是当前目录是最先找的，然后是系统目录，然后是环境变量指定的目录，还有自定的目录。这在脚本中经常会用到指定的库的根位置。
对于头文件，并不是所有文件都需要头文件。你的代码不需要调用其他功能，就根本不需要加载任何其他的库。利用头文件再加上路径，就可以实现符号的唯一。 不过问题的核心是符号的是如何组织的。
<dot>
digraph GCC {
      subgraph   cluster_flow {    
            label = "flow";
            rank= same;
            preprocessing -> compilation -> assembly -> linking;
      };
 
    subgraph cluster_software {
              rank=same;
              label = software ;
               sourceCode;
               compilerFile [label = ".S"];
               OBJFile [ label = ".o"];
               exeFile;
           }
        preprocessing ->sourceCode  [label = "gcc -E"];
        compilation -> compilerFile [ label = "gcc -S"];
        assembly   ->  OBJFile [ label = "gcc -c"];
        linking -> exeFile ;
</dot>
---++ 预编译
宏替换是全局的，所以要想保证唯一就要加各种各样的前缀，也可以gcc来查看各个宏的定义。
---+++ 如何解决编译的问题
*找不到头文件* ，是因为-isysroot,或者-I 没有设置需要的路径。到底设置了哪些路径，可以通过gcc -v 来得到来查看其真实的设置路径。当然还会一些其他的调试手段，这个与gdb 的过程是一样，那如何对于gcc扩展，也就是LLVM如何来操作呢。具体的可以查看 例如
       | -Q | 打印每一个编译时的函数名 |
       | -fmemxxxx | 可以查看内存一的一些东东 |
       | -fdump-rtl-xxx | 还可以查看寄存器的分配 |
       | -d{a,A,D,H,p,P,x} | 来实时查看各种宏定义 |
       | -print-xxxx |  来查看各种配置 |
       | -dump{machine/specs} | 查看机器配置 以及specs |
详情见   gcc manual 3.9 Options for Debugging Your Program or GCC，基本上编译所有过程都是可以debug的。所以以后遇到问题，要能够用以前学过的那些编译理论来进行推理，并且通过这些命令来进行验证。VS的好处就是可以只编译一个文件，与配置每一个文件的编译属性，那个与makefile是一样的，make采用每个编译的都要指定编译参数，并且通过变量来进行复用。例如右键来设置命令行参数或者属性来进行调试。例如 -E -v 就可以通过 -o file 来可以查到预处理的结果，预处理结果会有注释，#include 是从哪个文件进来的。并且可以调试那些预处理命令。 今天问题的关键是没有思路，不知道遇到这个情况去利用已经有的知识去解决，单个文件的处理与大规模的处理之间的关系。 并且编译参数都是可以由环境变量来指定的，例如bash中可以用环境变量PERL来指定系统所使用的perl.
关于gcc的更多问题，还可以查看200711-GCC-Internals-1-condensed.pdf，以及manual.


*找到的文件不是你想要的*
这个就是今天link.h  的内容不对，原来apex取了ndk中的link.h了，如何解决这个问题，
   1. 快速搜索一下有多少个link.h，在linux 下使用find,grep,sort,diff等，而在windows下可以使用powershell,gci+select-object+out-file 等等。
   1. 利用gcc 的 -E -v来查看一下，它 include进来的结果到底对不对。<verbatim> gcc -E -v -o file </verbatim> 就可以查看到file中的预处理内容，预处理注释信息是用# 来说明，在第几行加载的。
   1. 可以根据规则，#include <>,"",以及使用这些参数来控制优先级 [[http://gcc.gnu.org/onlinedocs/gcc/Directory-Options.html][Options for Directory Search]]  优先级，-I 要高于-isysroot, “” 会基于源文件的当前路径，而不会去找父路径。当前，-I,-isysroot.
       | -I  |
       | -iquote|
       | -b | 查找exe  文件 |
       | -isysroot |  

 编辑器找到文件，与gcc找到文件可能是不一样的。但通常情况是一样的。 也可以通过#error 等指令来进行判断。  同时预处理文件格式说明参考[[http://gcc.gnu.org/onlinedocs/cpp/Preprocessor-Output.html][Preprocessor-Output.html]]
---+++ 选项分类
| -m |Machine Dependent Options | -mfpu |
| -M | 根据include以及宏定义自动产生 makefile的依赖规则 | 在make 中可以$CC --M 来使用 |
---+++ BFDAandABI
| PE |  [[http://www.mouseos.com/assembly/07.html][PE structure study]] |
| ELF |

ABI 指的就是[[http://www.cnblogs.com/yizhu2000/archive/2009/03/24/1420953.html][ELF,COFF,和PE COFF]]这些东东，可执行文件的格式。不同的操作系统是不一样的。思考一个问题，同一个CPU对应的汇编指令是一样的，并且结构也都是一样的，但是为什么ABI为什么会不一样的。原因不同的ABI是内存管理分配的方式是不一样的。并且代码组织方式也都是不一样的。 例如[[http://mentorembedded.github.io/cxx-abi/abi.html][C++ABI]]这里描述了各种虚表的实现方式。

一个可执行文件对于外部库是不知道的，只是生成一个占位符，然后由加载器在加载的时候，去查找其位置，并把其替换成对应的地址。

对于面向对象的编程，函数表是在运行时，还是只存在于编译阶段，应该是都有吧，要不然，RTTI如何来做的呢。 

什么东东需要知道ABI，OS kernel, linker,dynamic linker, 以及GDB需要知道这些。当然正常情况下都是可以自动识别的
另外就是处理器自身的编码格式，例如ARM采用的固定长度的编码。可以采用哈夫曼编码。所以ABI应该包含两部分，一个汇编指令集本身，另外一种它本身的结构了。汇编就是是汉字一样，要组成一文章还要一些文法结构。例如诗体，散文等。
[[http://sourceware.org/gdb/onlinedocs/gdb/ABI.html][对于GDB你也可以改它的]].
   * [[http://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html][ABI Policy and Guidelines]]
   * [[http://wangcong.org/blog/archives/1573][API 与 ABI]] 一个通俗点的解释。并且可以检测这种变化的。
   * [[http://www.360doc.com/content/10/1119/15/1801810_70694111.shtml][向其它应用程序地址空间注入代码]]
   * [[http://blog.csdn.net/xieqidong/article/details/2391240][PE格式文件的代码注入 ]]
   * [[http://www.programlife.net/code-injection.html][代码注入技术]]
 [[http://blog.csdn.net/estate66/article/details/6061642][ptrace应用之三代码注入]] 也可以利用[[http://www.freebuf.com/articles/system/6388.html][gdb的脚本能力进行代码注入]]<verbatim>set write on ;show write </verbatim> 注意的是动态库libdynlib.so在编译时指定了-fPIC选项，用来生成地址无关的程序。
也可以利用ld脚本来进行代码注入。利用gcc进行注入的方法，也当然bell lib 所采用一种方式。 
*COFF file structure*
<verbatim>
1. 文件头（File Header）
2. 可选头（Optional Header）
3. 段落头（Section Header）
4. 段落数据（Section Data）
5. 重定位表（Relocation Directives）
6. 行号表（Line Numbers）
7. 符号表（Symbol Table）
8. 字符串表（String Table）
Linux下使用nm命令查看符号表，使用strip删除符号表。
Windows下符号表直接保存在.pdb文件中，使用symview软件查看符号表。
[[http://gcc.gnu.org/ml/gcc/1997-10/msg00312.html][.eh_frame section]] 
</verbatim>


when you add -g to gcc, when compile will add *.loc  .Ldebug_info:*  in assembly code and assembly will instore these in the symbol table fnd String Table and LineNumber Table of objfile.  without -g, these information will be striped, so will can't reverse back which line to line. 

Object file is almost same with .exe file. the most different is that the address and entry points.

*Options for Code Generation Conventions*

Most of the options are prefix with -f. for different requirement, there is need different code(this code means final code,not the immediate code). for example the share lib need position-independent code. 

elf,pe these are ABI, each one has its own structure, it specify the how the program is load into the memory, and this memory allocation for the process, where put the data,where put the code. where put on the resource.  each section has its own function. when and how to use it  and triger these code has specification. the how  is virus generate and not to infect the exe file. all is base on ABI,  

*Virus* the probelm for virus is how to triger execute malicious code. you utilize init stage or change standard lib call, this is good method, you can wrap the standard share lib call, interrupt the call link, for example, you change printf call, you change intercept printf, after execute you code and then return nomal printf. so you need study standard libc. how many call. how the share lib call. one of method change linker and loader of the system.
the other method you can exception handle to trigger your code.  [[http://dwarfstd.org/doc/dwarf-2.0.0.pdf][dwarf]] is this way, this paper is also put on kuaipan/debug,  there is the [[http://katana.nongnu.org/doc/katana.html][katana]] you can use it to do hotfix for binary code. for example currently running process. %RED%use this to implement Dynamic linker of exe%ENDCOLOR%

[[https://wiki.linaro.org/KenWerner/Sandbox/libunwind?action=AttachFile&do=get&target=libunwind-LDS.pdf][Libunwind]] this use ABI layout to discuss manipulate the stack of programming. there is a project [[http://www.nongnu.org/libunwind/][libunwind]], and Pentak begin add this. if So, it support *SetJump* directly.  how to control CPU flow, one is use assemble. the other is that you just add function to the target program.  As long as, the input and output is legal.   
<verbatim>
main ()
{
    A=B+C;
    callFunction1();
    callFunction1.5();
    callFunction2();
}

 function 1.5 is virus, but desn't not destroy you code, but it also get the executed. 
as you can't get the source code, so you need add it as ABI level of assembly level. as now,  you insert any code you want.
</verbatim>
---+++ LD
[[http://www.ibm.com/developerworks/cn/linux/l-dynlink/][程序的链接和装入及Linux下动态链接的实现]] 编译的时候，只处理本地符号，本地找不到就会标识成未定义的，然后由linker去查找修改。如果linker也找不到，就会报错了。所以出错，首先要看你调用是本地的还是。。 你可以用gcc -c 只编译成obj文件。可以使用objdump查看obj文件。例如 -dx还可以看到反汇编。 你可以通过find + objdump 来进行查找各种符号与汇编的信息。虽然不要求读懂每一行，但要知道常用调用，函数的开头与结尾要能够看出来。
linker is loader's brother, and reversely. One of problem is how to redirect the address of your program.  and GDB support this feature for debugging. 

normally the lib linker order is not specially, but sometimes you need a specific order. but the linker loaded it by the order you specify it.  当然如果出现你已经加载了某一个库，但还是报找不到链接或者未定义，这个时候应该就是链接顺序的问题了。 [[http://www.cppblog.com/findingworld/archive/2008/11/09/66408.html][gcc 库顺序问题解决方法]]。 并且可以用strace来跟踪你的应用程序调用哪些API。可以轻松知道应用起动的过程都做什么。

如果修改系统库的一些函数，这个时候，不需要加载系统库，不然会冲突，这个时候，你可以用 -nostdlib 或者-nodefaultlib等来做。libgcc就是其中之一。但是大部分程序都会需要它，-llibgcc. 
当然如果想hook一个API时，在linux 下很简单那直接写一个自己.so 然后再加上一个LD_PRELOAD,这样应用程序在调用应API时，就会先在[[http://rafalcieslak.wordpress.com/2013/04/02/dynamic-linker-tricks-using-ld_preload-to-cheat-inject-features-and-investigate-programs/][LD_PRELOAD库去找]]。 而在windows 下会有一个 [[http://easyhook.codeplex.com/][easyhook]] 与MS 的detour 来实现。
 
应用程序在加先从应用程序的地址来判断这个地址在哪一个库里，然后再查表找到相对应的库的符号表去查询。但是如何编译ABI不一样，例如Ｃ直接调用Ｃ＋＋函数是不行，你还是发现找不到函数定义的，原因在于Ｃ＋＋的函数在mangle方式与Ｃ的是不一样的，并且符号表结构也可能是不一样的。这样当然也就找不到了。

在解决链接问题的时候，要注意两点，对于编译问题，VS支持从当前编译路径去查找，所以在找不到定义的时候，自己或以来用这个方法来解决，如果却实没有，那就是漏了一些源码目标或者头文件。用-I 来添加。
对于链接问题，一个是用-L 来添加搜索目录，例外要用-l 来指定库名。 而-I(include)加载头文件，-isystem加载系统头文件。 并且通过预编译指令来控制编译。例如各种宏定义。


[[http://blog.chinaunix.net/uid-27105712-id-3313293.html][-Wl,--as-need]]这样就可以避免链接不必要的库，另外ldd -u 可以查看到哪些库链接了，但是根本用不着。 
* -Wl* 可以直接把参数传给linker, *-Wl,-z,no[[http://linux.die.net/man/8/execstack][execstack]]
现在终于明白C语言指针可做硬件灵活性在哪里，C把格式变成编格式就是最好LLVM了，并且C语言中指针，将来就是真实内存地址。当你想crack一些系统或者硬件行为的时候，利用C语言可以达到汇编直接操作，例如函数指针，例如符号表的得到，原来系统函数的地址，然后把地址改在自己的函数，并且函数的声明要原来一样，保证调用不会出错，然后自己处理，再调用系统函数，这也是各种wrapper的写法。在perl里，只就直接使用$e这些中断函数处理通过hook__DIE__这个函数调来实现的，在语言可以trap自己的函数来对segmentfault以及abort,exit等等进行hook处理。或者直接启动调器来工作。现在明白syscall有漏洞的用法了，因为syscall是不受权限限制，可以通过内核启动自己程序。这样解决权限的问题。

这就是如何用语言得到汇编的控制水平，因为在汇编可以任意改变PC值来改变执行的流。明白了汇编到了高级语言失去了什么。失去了对硬件直接控制，同时提高通用性。例如汇编直接硬件机器的指令，以及直接操作硬件的各种信息。而高级语言则失去这种控制，但来的通用性。但在有些时候，还想直接控制如何处理呢，可以通过在C语言中直接使用汇编来处理。另一个办法那就是找到精确的对应，例如如何直接控制PC值呢。当然在嵌入式编程中C语言是可以控制寄存器的。
| CommonLib |
<blockquote class="foswikihelp">
Code Overlays
If your program is too large to fit completely in your target system's memory. we could use =overlays= to work around this problem. 
</blockquote>
   * [[http://blog.csdn.net/yili&#95;xie/article/details/5692007][LD 讲解]] 
   * [[http://www.zemris.fer.hr/~leonardo/oszur/tehnicki.dokumenti/gnu-linker.pdf][gnu-linker manual]]
   * [[http://www.ibm.com/developerworks/cn/aix/library/au-unixtools.html][UNIX 目标文件初探]]
   * [[http://www.latelee.org/using-gnu-linux/114-using-ld.html][ld命令初识]]
   * ldconfig 用来管理与更新动态连接库的，更新/etc/ld.so.cache 例如 -p 就会打印系统所用到动态链接库。
   * [[http://stackoverflow.com/questions/3476093/replacing-ld-with-gold-any-experience][ld.bfd vs ld.gold]]  it seems ld.gold can't compiling the kernel.
   * [[https://sourceware.org/binutils/docs/ld/Options.html][ld参数]] now 主要解决符号解析，与segment的创建。



---+++ [[LLVMStudy][ LLVM ]]
 
---+++ [[SymbolTable][符号表]]

---+++ float 点数
这个是每家处理器一个竞争的功能，每家的功能也不一样。
  * [[http://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html][对于浮点数，硬件支持，还是软实现，它的ABI也是不一样的。]] 
  * [[http://doc.ironwoodlabs.com/arm-arm-none-eabi/html/getting-started/sec-armfloat.html][sec-armfloat]]
---+++ See also
   * [[http://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html][abi]] %IF{" 'application binnary interface, the object file structure and naming rule' = '' " then="" else="- "}%application binnary interface, the object file structure and naming rule


   * [[http://www.mouseos.com/index.html][mouseOS 技术小站]] %IF{" '关于汇编与机器码一个非常好的站' = '' " then="" else="- "}%关于汇编与机器码一个非常好的站
   * [[https://developer.apple.com/library/mac/#documentation/MacOSX/Conceptual/BPFrameworks/Tasks/IncludingFrameworks.html][Including Frameworks]] %IF{" '' = '' " then="" else="- "}%
   * [[http://gcc.gnu.org/wiki/Graphite/PolyhedralInterface][PolyhedralInterface]] %IF{" '' = '' " then="" else="- "}%
  
   * [[http://blog.csdn.net/sonicling/article/details/6702031][gcc 源码分析]] %IF{" '' = '' " then="" else="- "}%
#ReferenceLink
%TWISTY{link="add a bookmark"  imageleft="%ICON{edittopic}%"}%
%COMMENT{type="bookmark"  location="#ReferenceLink"}%
%ENDTWISTY%

---+++ thinking


*profling*
when you want profiling with Gprof,gcov (gnu coverage of code), you need compiler with -pg,  or use the ld .  normally there are three version:
   1. release  strip the debug symbol
   1. debug   add the debug symbol
   1. profiling  add the tracing function for gather the information
<verbatim>
ld  -o myprog /lib/gcrt0.o myprog.o  utils.o -lc_p 
</verbatim>
the real system is that ctr0.o 

-- Main.GangweiLi - 21 Mar 2013



-- Main.GangweiLi - 25 Mar 2013


*objcopy*  you use it do format transform directly on .o and o.bin file.  http://hi.baidu.com/weiweisuo1986/item/b8a142b8e3e46cec4fc7fd05
http://book.51cto.com/art/200806/78862.htm.

-- Main.GangweiLi - 25 Mar 2013


为什么避免干扰，一般把生成的/lib, /obj /build目录都分开，那么些在make or ant 是如何设定的。

-- Main.GangweiLi - 13 Apr 2013


*代码的生成方式*
--enable-static-link, --disable-shared -static

-- Main.GangweiLi - 15 Apr 2013


*debug information*
<verbatim class="tmpl">
-gtab  produces debug info in a format that is superior to formats such as COFF.
-gdwarf-2 is also effective form for debug info.
</verbatim>

-- Main.GangweiLi - 16 Apr 2013


*如何查看当前编译的各种配置*
gcc会有一个配置文件，spec 文件。 同时也提供了各种参数供你来查询，例如-dumpXXX,-printXXXX等。同时也-spec 来指定配置文件。 具体的语法是3.1.5.并且gcc 只是一个前端，他在后端去调用各种宏替换，以及编译器，连接器等。所有的参数都是分发都是根据配置文件来定的。如果这样的话，是不是可以利用gcc的壳来实现一些自己的东西。gcc 的强大在于，支持重多的参数多，把各个后台的参数都集中起来。 并且这个配置文件也是支持脚本的。看来脚本在计算机大老里是一个很容易的事情。自己是不是去读一下
[[http://www.adintr.com/mytranslate/gcc_spec_files.html][reference1]] ,[[http://www.mingw.org/wiki/SpecsFileHOWTO][Howto SpecsFile]] 配置toolchains的过程其实就是很大一部分工作就是这个specfile的修改过程。 自己做导出4.7.2与4.7 spec 可以通过diff,同时学习下这些语法。\\netapp-sh\devtools\usr\victorli\code Study\gcc
并且对于这种脚本语法进行一下总结。类似于gawk,他们表一般都一些全局的特珠变量，以及正则表达式的替换规则，以及巴斯特范式。 
-- Main.GangweiLi - 25 Apr 2013


*如何解决循环依赖*
[[http://en.wikipedia.org/wiki/Circular_dependency][Circular Dependency]]可以动态替换的方式。产生了鸡与蛋的问题。对于gcc 可以使用--start-group --end-group / -(  -) 这样来保证的循环。一般情况下。LD会自动判断依赖的。  [[http://www.cppblog.com/findingworld/archive/2011/07/12/66408.html][gcc 库顺序问题解决方法]]
*lib.a*  静态库，*lib.o*动态库。

-- Main.GangweiLi - 25 Apr 2013


*-W*来控制所有的告警，gcc把后端的所有输出都集中这里，这个是如何做到，并且保持这种灵活性。

-- Main.GangweiLi - 25 Apr 2013


*gcc 对于管道的支持*
巧用：
<verbatim>
echo -e '#define cat(c,d) c##.d \n #define mb(a,b) a##@b \n mb(cat(xiyou,wangcong),cat(gmail,com))'  \
| gcc -E -xc - 2>/dev/null |tail -n 1

from http://wangcong.org/
</verbatim>

-- Main.GangweiLi - 25 Apr 2013


*[[http://blog.chinaunix.net/uid-25871104-id-2938389.html][FP寄存器及frame pointer介绍]]*
函数调用的栈的标志位，这个这个寄存器来快速得到当前那个这个函数栈长度。如果没有，就只能根据指令来了。对于backtrace时就会很麻烦。一般情况下没有了FP，很多系统不支持backtrace.为了简单。
[[http://www.delorie.com/gnu/docs/gcc/gccint_115.html][Register Usage]]
这么多年的困惑终于明白了，一直想知道C语言如何来直接操作寄存器的。原来在编译的时候，可以根据ABI接口来定义寄存器的分配规则。来动态分配。为了能够尽可能接近人直接编写汇编的效率，人们对于编译原理进行深入的感觉 ，并且研究各种算法来帮助我们实现。目前最新的LLVM采用SSA的方法大大简化了跟踪方法。只要分析抽象分析归纳终究是能够找到好的方法的。正因为有编程原理，我们才可以利用向自然语言的描述与机器打交道。只要找到一种简单有效的map规律就可以简化我们操作。


-- Main.GangweiLi - 08 May 2013


PentaK has three configuration
<verbatim>
debug   -g  -O0    -fno-omit-frame-pointer
profile   -g   -03    -fno-omit-frame-pointer
release        -03  -fomit-frame-pointer
</verbatim>

-- Main.GangweiLi - 08 May 2013


*如何在代码中控制优化的行为*
gcc 6.30 Delcaring Attributes of Fuctions,  定义了对函数的各种属性，以及变量也有各种属性，例如volatile, register等。都是为了控制编译与优化的。告诉你这一段代码有什么特性。还让编译器来做一些特定的事情。就个与今天所听到openACC。通过指令来标记代码，来让编译器来优化与改变。例如多核，情况下来保护现有代码。例如可能把所有代码都重新再用cuda写一遍吧。例如这里有各种[[http://www.cnblogs.com/respawn/archive/2012/07/09/2582078.html][实验]],同时也想起当然那个bell lib的那个有趣破解故事。[[http://blog.csdn.net/iamoyjj/article/details/4195635][__declspec]] C99标准里只有extern, static等几个关键字。

-- Main.GangweiLi - 09 May 2013


*对于预编译* 如何预防重复的加载呢，以及循环加载呢。采用宏定义，不能完全避免。因为你也不知道你的include的文件里已经include了。[[http://zhidao.baidu.com/question/112685790.html][#if ndefine pragma once ]] 当然另外一种预编译那就是提前编译好现成，可以只提供一个空文件名来骗过编译，只在链接的时候直接读库就行了。



*编译与连接问题* include路径不是嵌套原因，原因在搜索机制，它是简单通过再组装来判断文件是否存在进行搜索的。所在编译的时候，要么指直接用绝对路径来指，要么就是先指路径名，然后再指文件名，这样让编译器的搜索机制来处理，当然这会有冲突，这个与搜索顺序有关。找不到的原因，经常的原因是路径有空格之类的问题，不管IDE 工具的什么样的继承，或者additonXXX之类，不过是都是编译的-I XXXX 中一员而己，无非是编译的顺序不同而己。在IDE中出现这个问题，很大部分原因会是编译器并没有把选项传递给编译器。 现在突然明白了所谓的IDE工具都是如何工作的了。并且有IDE工具在收集错话的过程会把详细的信息给丢了。只有最后的yes or no的信息，如何才能收集到更加信息呢。那就是直接在命令执行这个编译命令。并且还可以打开编译器的log信息。来进一步定位。

另外一方便也可能是toolchain本身的兼容性,特别是ld.更是如此, 以及如忽略那些undefined symbols.等等问题。




-- Main.GangweiLi - 02 Jul 2013



*如何在代码中加汇编*
一个方式那就是直接ASM（），具体的语法可以看Inline CTX in CUDA.pdf  相当于一个函数调用，参数传递函数参数的传递，但是代码是直接copy到输出的。
其实原理也很简单，就是m4中的替换原则，这个就是那些直接copy输出到就行了。其实M4是原始的编程语言，可以直接实现各种转换，而scheme需要少量的delimiter同样实现这些。所谓的那些lambda理论都是可以用m4 来实现。不过现在都简化成列表了。其实更加像现在sphinx一样，加入少量的原语标记，就可以实现实时再编程。把CDF直接做出来，就像我可以简单在一个文本简单的处理一下，可以变成python的collection,dictionary或者复杂结构了，解决xml更加简单的做法，那就是直接替换成python的数据结构，直接实现嵌套进去就解决了。
例如xml->.py -> import it. this is perfect. no need other lib to do this.哈哈看来可以把文本处理再提高一个水平。后面直接scheme或者haskell来实现与解决这些。看来需要时间把rackit抓紧时时间学一下，然后研究一下王垠的那些理论了。同时也慢慢对LLVM会有更深的认识了。
