Bash 编程
*********

优点与缺点
==========

简练，最接近系统命令，并加上简单的流控就实现了就解决了。

这也是为什么bash一直没有被取代的原因之一。这也是各种DSL语言流行的本身。

缺点也很明显，一个是变量没有作用域，主要靠人为的添加前缀来分区。

并且把输入与输出通化很历害。

现在回想一个tcl,自己的语言能力很少有几个达到自己tcl的水平。

对于bash来说，`` 反勾号的作用相当于tcl中[],表达式其实也就是eval替换的过程。
*() in bash*
可以用以进程替换，再加>，<就像管道了。 ,$()就当于相当于 subst可以任意次的替换，而不相双引号与反勾号替换执行次数。
并且今天添加了cleanApk这样功能，让大家都来用这样才能显示自己的实力。

例如xargs列表也会有妙用。 :command:`man xargs`
(()) 数学计算的扩展。

自动补齐
========

:command:`apt-get install bash-completion` 

并且随着 bash的升级，4.3之后已经可以 自动补全 参数了。看来是越来越强了。如果是想自定义可以使用
http://kodango.com/bash-competion-programming

串行与并行计算与同步
--------------------

 简单的管道是串行，而并行就要用() 再加上这些与列表与或者表了。不过bash实现都是进程级的并行了。
()&&()|tee log.txt

而简单的语列表与或列表是串行的，如果加()就是并行了，同并与或之间也就具有同步的机制。

并且sh 中很有函数式编程味道。

并且bash 命令回显机制是做的最好的，-verbose以及打印命令回显呢。

所以对于bash来说，直接看其执行的log就可以了。这样就可以利用gentoo把整个启动过程完全搞明白了。



对于文件的读写
--------------

bash 是最简化的， read 指定就可以，写可以用echo也可以write以及重定了。

例如读入前三行

.. code-block::
    
    { read line1
      read line2
      read line3
    } < /etc/fstab


这是多么的简练，原来perl中那些符号也都是从这里来的吧。并且bash中的read指定很强的。

不仅支持 timeout还支持 列表输入，就像 a,b,c=1,2,3这样。并且自动把多余给最后一个。
还可以指令一行，还是一个字符，还是指定分界符。还可以设置不回显等等。

bash 有最好用重定向
-------------------

.. code-block:: bash

   { code-block} >> output.log

例如下边的例子，生成 :file:`/etc/udev/rules.d/70-persistent-net.rules` 的 
:file:`/lib/udev/write_net_rules` 生成函数。

.. code-block:: bash

   write_rule() {
           local match="$1"
           local name="$2"
           local comment="$3"
   
           {
           if [ "$PRINT_HEADER" ]; then
                   PRINT_HEADER=
                   echo "# This file was automatically generated by the $0"
                   echo "# program, run by the persistent-net-generator.rules rules file."
                   echo "#"
                   echo "# You can modify it, as long as you keep each rule on a single"
                   echo "# line, and change only the value of the NAME= key."
           fi
   
           echo ""
           [ "$comment" ] && echo "# $comment"
           echo "SUBSYSTEM==\"net\", ACTION==\"add\"$match, NAME=\"$name\""
           } >> $RULES_FILE
   }
   
*重定向代码块的输出* {} >log.txt 直接一段代码所有输出都重定向到文件中。这样可以分以直接compile的log分开保存起来，在其内部直接重定向。

<< 重定向到文件，从文件中读取。
<<<就是 "here string" 就是python 中"""三目符的用法。


更好完的重定向要属端口应用功能 了。

:command:`mknod /dev/tcp c 30 36` 就可以STDIN/STDOUT/STDERR一样重定向了。
进程替换
========

特别具有函数编程有味道，例如

:command:`diff <(ls $first_directory) < (ls $second_directory)` 把半命令的输出直接来对比。

这个正是自己一直要想要的结果吗。


/dev 与 /proc
==============

特别是/dev/tcp   /dev/upd这些伪设备也是很好完的。

.. code-block:: bash
    
    cat </dev/tcp/time.nist.gov/13

就得到的实现。


精确的文档生成
==============

对于linux 下大部分的命令输出都是可以参数可控控制，并且大部分命令都支持 与或非
同时直接支持把结果当命令进一步执行这个不正是自己之前到 tcl 用到 subst 功能吗。

同时也就具备了m4 的部分功能。

.. code-block:: bash

   $> 
   -> for cl in 19156448 19064514 19006994; do p4 shelve -r -c $cl && echo -e "-------------\n"; done
   Shelving files for change 19156448.
   add //sw/README.mkd#none
   add //sw/TestPlan.pm#none
   add //sw/build_checker.pl#none
   add //sw/build_installer.pl#none
   add //sw/builds/aardvark/nightly/20141218_aardvark_nightly_debug/data/hello.txt#none
   add //sw/builds/aardvark/nightly/20141218_aardvark_nightly_debug/data/world.txt#none
   add //sw/builds/aardvark/nightly/20141219_aardvark_nightly_debug/data/hello.txt#none
   add //sw/builds/aardvark/nightly/20141219_aardvark_nightly_debug/data/world.txt#none
   add //sw/builds/aardvark/nightly/20141219_aardvark_nightly_debug/installer/installer.pl#none
   add //sw/test_project/data/taskEntry.pl#none
   Change 19156448 files shelved.
   -------------
   
   Shelving files for change 19064514.
   edit //sw/devtools/QA/Tools/Farm/exec/Nexus/Submit_ToT.pl#4
   Change 19064514 files shelved.
   -------------
   
   Shelving files for change 19006994.
   edit //sw/doc/code-notes.mkd#1
   edit //sw/FarmEntry.pm#33
   add //sw/BuildCheckerV2.pl#none
   add //sw/d/TestPlan.pm#none
   add //sw/AppConfigValidator.pm#none
   add //sw/Machine.pm#none
   Change 19006994 files shelved.
   -------------






command complete
================

如果这个做好，可以大大加快工作效率。例如   
#. `More on Using the Bash Complete Command <http://www.linuxjournal.com/content/more-using-bash-complete-command>`_  可以利用来自定义命令补全，是可以加上过滤条件的
#. `Programmable-Completion <http://www.gnu.org/software/bash/manual/bash.html#Programmable-Completion>`_  bash 中有专门的文档来说明，据说zsh的补全做的最好。
#. 目前在对于android，已经有现在与补全功能了，在sdk/bash_compeletion/adb  加载了它之后，android下就可以自动补全了。
#. `zsh adb completion  <https://github.com/zsh-users/zsh-completions>`_  

See also
========

#. `bash中trap的用法 <http://hi.baidu.com/jackbillow/item/7310670e8eae9d19eafe38cc>`_  bash 可以接收64个中断
#. `zenity 一个小巧方便的用户交互的GUI. <http://os.51cto.com/art/201011/235135.htm>`_  ,`zenity for windows <http://www.placella.com/software/zenity/>`_ 
#. `zsh it was said to be the best shell until now <http://www.zsh.org/>`_  

#. `bash-utility-script-library <http://stackoverflow.com/questions/11369522/bash-utility-script-library>`_  为什么bash没有库，因其函数没有返回值，基本都是全局空间，没有什么封闭性，可以就很难在大范围的适用。
#. `Advanced Bash-Scripting Guide <http://www.tldp.org/LDP/abs/html/>`_  终于找到这个在线版本
#. `tf-idf-hadoop-streaming-bash-part-1 <http://www.oraclealchemist.com/news/tf-idf-hadoop-streaming-bash-part-1/>`_  

Thinking
========



*$@*
exec /usr/bin/flex -l "$@" 以前不知道为什么要有这些用法。现在明白了主要为了方便二次的转接。尤其在做接口函数的，这样可以无缝传给那些函数。正是通过些符号，我们很方便定制各种各样的命令，就样android中build 中envsetup,sh 中那些cgrep,regrep, 等等这些命令。进行二次封装可以大大加快的自己的速度。

-- Main.GangweiLi - 15 Apr 2013


*history skill*
   
.. ::
 
   ! Start a history substitution, except when followed by a space, tab, the end of
   the line, `=' or `('.
   !n Refer to command line n.
   !-n Refer to the command n lines back.
   !! Refer to the previous command. This is a synonym for `!-1'.
   !string Refer to the most recent command starting with string.
   !?string[?]
   Refer to the most recent command containing string. The trailing `?' may be
   omitted if the string is followed immediately by a newline.
   ^string1^string2^
   Quick Substitution. Repeat the last command, replacing string1 with string2.
   Equivalent to !!:s/string1/string2/.
   !# The entire command line typed so far.
   


-- Main.GangweiLi - 17 Apr 2013


*如何在shell环境中添加自己的命令*
之前自己干过，直接添加变量，或者直接在命令行赋值，直接添加全局变量，其实也很简单，那就是直接source 一个sh文件，它会当前的进程下执行。其本质那就是你是eval,exec,system,等等之间不同了。现在真正明白了这些操作区别，取决于如何得到这些操作以及结果。在python中脚本，那就execfile, 就像tcl的中source一样的。就像bash一样，我把可以把tcl,python直接当做脚本，但是perl是不行的，perl本身是没有交互环境。
并且在bash 中 ". " 点+ 空格就相当于source.
-- Main.GangweiLi - 01 Nov 2013


-- Main.GangweiLi - 03 Nov 2013


*man builtins* 可以看许多有用东东，例如bind就可以进行键盘绑定的。就像vi  的map一样。

-- Main.GangweiLi - 28 Nov 2013



---+++多进程
 {} & 就可以直接把这块代码放在了后台运行。
   
.. ::
 
   for i in `seq 1 100` ; do
       (ping www.google.com &)
   done
   
   
   maxjobs = 10
   
   foreach line in the file {
        jobsrunning = 0
        while jobsrunning < maxjobs {
            do job &
            jobsrunning += 1
        }
        wait
   }
   
   job ( ){
      ...
   }
   

 * `Bash script parallel processing (concurent exec) <http://ubuntuforums.org/showthread.php?t=382330>`_ 

-- Main.GangweiLi - 12 Feb 2014
