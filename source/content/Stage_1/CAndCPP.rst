类型转换
========

这个是各个语言，最灵活也是最难的部分。从最简单的说起。
#. 长短整型转换。
#. 整型与浮点型的转换。
#. 字符串与数字之间转换
#. 指针类型的转换。
#. 类的的类型转换

最后两者也是最复杂的。也是各种反射机制的基础。
http://www.cnblogs.com/chio/archive/2007/07/18/822389.html

类的转换并且还有一定的规则。可以用强制转换，来实现一些hook的功能，例如hook某一个类的调用。这可以这么用。
动态链接库，就有了中间的搜索查找的过程，就有了Injector的空间。


C++ 现在支持一定的类型推导了，`decltype <http://en.cppreference.com/w/cpp/language/decltype>`_ 
来得到目标的类型。

前置定义用途
============

一方面是用强耦合问题。 主要是用来解决编译的问题，由于走到当前，要求所有接口信息都要已知。但是现在需要东东，现在现在还没有编译怎么办。
这个怎么办呢，提前放一个stub。 这样就骗过编译。 但是骗不过linker. 因为linker是全局搜索的。如果连linker都骗过去，也就得再准备一分空函数库了。
然后在实际的运行的时候，再加上真实的库。 交叉编译就可以。 头文件就是这样一个作用。

从programming element来看的类，copy就是信息的传递修改的问题。

对于于不需要改变的变量，只需要传递引用就行了。没有必要生成一片内存，再copy就一样。 其实与文件的copy是一样的。
对于复杂的变量例如struct,以及class,这种大家伙来说，采用一刀切的方式显然效率不同。变样把结构分为变化问题，不变部分。
或者增量变量的部分。 面像对象的继承机制，可以看做这样的一种体现。例如基类基本上都是不变的部分。或者接口纯虚函数
无非函数指针。对于新增部分采用继承的方式。当然没有问题，对于override的也没有问题，有重载就行了。

而难点在于同一状态变量，要同时保存几个版本。例如Unreal中，Thread/Render中对象是共用的，但是为了加速，采用的异步机制。
至少double object的机制。计算当前的版本snapshoot一下，留给render,自己继续前进。 
对于复杂结构更是如此。如何解决object的copy问题是个难点，如何又省内存，又高效呢。当然再简单的方法全部copy，也就是所谓的浅copy与深 copy的区别。

所以变量结构设计的时候，变量是可读，可写，以及读写方式与范围建模好好定义。这样方便后面的内存的管理，以及实现copy的问题，例如static相当于只读，
而moveable,相当于是可写。

对于一个简单的变量是没有这样大的区别的。像Unreal中这些object不一样的。后面那些pipline的优化也主要是基于static,moveable的能够区分开来为基础的。

对于 STL中实现的，写时copy也是基于这样认识。其实也很判断。凡是从内存读到寄存品上时，不需要变化，而要把内容写回内存的时候，就要换一个地址来写了。
这于部分的优化，那如何move,load指令的操作优化。可以统计move,load指令的做统计分析。move到内存寄存器的多的，说明只读的多，反过来，那就是只写的多。

同样是一段01序列，经过那么多层的传递，真的就需要那么多重复操作吗。


函数调用实现
============

对于结构化的传统语言，背后的堆栈的建立，参数排列，返回地址，堆栈消除等机制。


base class subobject 在derived class的原样性。也就是保证其内存结构一致性。包括填充位也要保留。

http://glgjing.github.io/blog/2015/01/03/c-plus-plus-xu-han-shu-qian-xi/ 当子类继承父类的虚函数时，子类会有自己的vtbl，如果子类只覆盖父类的一两个虚函数接口，子类vtbl的其余部分内容会与父类重复。这在如果存在大量的子类继承，且重写父类的虚函数接口只占总数的一小部分的情况下，会造成大量地址空间浪费。在一些GUI库上这种大量子类继承自同一父类且只覆盖其中一两个虚函数的情况是经常有的，这样就导致UI库的占用内存明显变大。 由于虚函数指针vptr的存在，虚函数也会增加该类的每个对象的体积。在单继承或没有继承的情况下，类的每个对象会多一个vptr指针的体积，也就是4个字节；在多继承的情况下，类的每个对象会多N个（N＝包含虚函数的父类个数）vptr的体积，也就是4N个字节。当一个类的对象体积较大时，这个代价不是很明显，但当一个类的对象很轻量的时候，如成员变量只有4个字节，那么再加上4（或4N）个字节的vptr，对象的体积相当于翻了1（或N）倍，这个代价是非常大的。

对于不同抽象程度，存取的效率也是有区别，其实也还是用多少条指令。
额外的间接性会降低"把所有的处理都移到缓存器中执行"的优化能力。

inline in inline有可能失败。

C语言经典在于传统硬件模型与逻辑模型的分界线上。包括LLVM都是拿C语言的形式做为标准语言。

而C++实现把数据与操作bind在一起的功能，但是底层还是与C一样，用同样的ABI。但是通过编译器实现实现一些相当于元语言的操作，再加上编译器内部的结构。同时自动类的内存结构，来方便继承与修改。
而在C里，所有结构都要自己手工基于硬件模型来构造。 而c++则是基于逻辑模型来构造，然后由编译器当你构造出对应内存struct来，再加一些额外的overhead.c++自动给利用链表给添加不少东东。而在
C中这些都是自己明确实现的。 

另外c++的成员函数指针，都是基于对象的偏移量，所以指针要加上类的类型。

C++的原理自己想实现的DSL的原理是一样，只是更加复杂了。高级语言要解决的问题，即要能保持高级语言的灵活与逻辑概念。同时又不产生的垃圾overhead代码到下一层的语义中。并且尽可能智能的化简。
或者可视化的理解让人们半手工来进行优化。C++是目前之这方面最好的。一个重要原因，就是基于C演化过来的。而C语言是对硬件抽象的最好，并且也是优化的效率最高的语言。
然而但C语言的这一点，慢慢就可以被LLVM来取代，所以目标，把DSL语言翻译成LLVM原语，然后再LLVM来进行优化，以及进行到硬件级别的优化。

明白每级语言向下翻译的基本原理，利用编译器+半手工调优，来实现性能与灵活性平衡。


内存结构 
========

http://www.cnblogs.com/kekec/archive/2013/01/27/2822872.html， c++的结构主要也是通过链表来实现。 并且也是多级，如果你只是用到一个类的很少一部分功能，但是还是要继承这个类，这样是很浪费内存空间的。 类型的改变只是改变了如果读那一段内存结构。

c++的内存结构解析类似于TCP/IP协议包的解析结构，都是采用头尾添加方式，root class就相当于最上长层协议包。 继承就是不断添加包头与包尾的方式。


泛化编程
========

泛化编程，相当于在编译当做运行了，只过其输出是代码，还需要进一步编译。 其实简单就像现在自己经常写的log,格式规整一点，直接就是另一种语言。 相当于让编译器帮你写代码的过程。
也就是进一步的符号编程。  变量/对象 -> 类/类型-> 符号


其实是大数据分析时，采用泛化编程就可以实现自我演化的图灵机了。通过聚类得到一些属性，然后自动组成生成代码，进一步的执行。这样不断的演化就可以了。

泛化编程是图灵完备的。 

泛化编程不单是可以只类型，可以任意你要替换的对象。

主要用来实现代码的排列组合。


非类型模板参数
==============

可以简单理解为一个全局常量的角色，只不过是在编译时计算出来的。经过这几天搜索，又一步一步的走到代码的演化。

TypeList
========

可以添加与替换其默认值。 并且在编译期间提供了一般list的绝大部分基本功能。
可以结合元编程理解这些东东。 

如果你真的想不到typelist的用途，那是因为确实没有用到的需求，你知道有这个东西的存在就好了。有一天你碰到某个问题抓耳挠腮的时候，忽然想到typelist，马上就会用到火星的生产力耶。

http://blog.csdn.net/win2ks/article/details/6737587



